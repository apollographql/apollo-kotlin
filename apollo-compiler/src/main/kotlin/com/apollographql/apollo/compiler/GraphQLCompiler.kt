package com.apollographql.apollo.compiler

import com.apollographql.apollo.compiler.codegen.kotlin.GraphQLKompiler
import com.apollographql.apollo.compiler.ir.CodeGenerationContext
import com.apollographql.apollo.compiler.ir.CodeGenerationIR
import com.apollographql.apollo.compiler.ir.ScalarType
import com.apollographql.apollo.compiler.ir.TypeDeclaration
import com.apollographql.apollo.compiler.operationoutput.OperationOutput
import com.squareup.javapoet.JavaFile
import java.io.File

class GraphQLCompiler {
  fun write(args: Arguments) {
    val ir = args.ir
    val customTypeMap = args.customTypeMap.supportedTypeMap(ir.typesUsed)

    if (args.generateKotlinModels) {
      GraphQLKompiler(
          ir = ir,
          customTypeMap = args.customTypeMap,
          operationOutput = args.operationOutput,
          useSemanticNaming = args.useSemanticNaming,
          generateAsInternal = args.generateAsInternal,
          kotlinMultiPlatformProject = args.kotlinMultiPlatformProject,
          writeTypes = args.writeTypes,
          enumAsSealedClassPatternFilters = args.enumAsSealedClassPatternFilters.map { it.toRegex() }
      ).write(args.outputDir)
    } else {
      val context = CodeGenerationContext(
          reservedTypeNames = emptyList(),
          typeDeclarations = ir.typesUsed,
          customTypeMap = customTypeMap,
          operationOutput = args.operationOutput,
          nullableValueType = args.nullableValueType,
          ir = ir,
          useSemanticNaming = args.useSemanticNaming,
          generateModelBuilder = args.generateModelBuilder,
          useJavaBeansSemanticNaming = args.useJavaBeansSemanticNaming,
          suppressRawTypesWarning = args.suppressRawTypesWarning,
          generateVisitorForPolymorphicDatatypes = args.generateVisitorForPolymorphicDatatypes
      )

      ir.writeJavaFiles(
          context = context,
          writeTypes = args.writeTypes,
          outputDir = args.outputDir
      )
    }
  }

  private fun CodeGenerationIR.writeJavaFiles(context: CodeGenerationContext, outputDir: File, writeTypes: Boolean) {
    fragments.filter { it.filePath != null }.forEach {
      val typeSpec = it.toTypeSpec(context.copy())
      JavaFile
          .builder(context.ir.fragmentsPackageName, typeSpec)
          .addFileComment(AUTO_GENERATED_FILE)
          .build()
          .writeTo(outputDir)
    }

    if (writeTypes) {
      typesUsed.supportedTypeDeclarations().forEach {
        val typeSpec = it.toTypeSpec(context.copy())
        JavaFile
            .builder(context.ir.typesPackageName, typeSpec)
            .addFileComment(AUTO_GENERATED_FILE)
            .build()
            .writeTo(outputDir)
      }
    }

    if (writeTypes) {
      if (context.customTypeMap.isNotEmpty()) {
        val typeSpec = CustomEnumTypeSpecBuilder(context.copy()).build()
        JavaFile
            .builder(context.ir.typesPackageName, typeSpec)
            .addFileComment(AUTO_GENERATED_FILE)
            .build()
            .writeTo(outputDir)
      }
    }

    operations.map { OperationTypeSpecBuilder(it, fragments, context.useSemanticNaming) }
        .forEach {
          val packageName = it.operation.packageName
          val typeSpec = it.toTypeSpec(context.copy())
          JavaFile
              .builder(packageName, typeSpec)
              .addFileComment(AUTO_GENERATED_FILE)
              .build()
              .writeTo(outputDir)
        }
  }

  private fun List<TypeDeclaration>.supportedTypeDeclarations() =
      filter { it.kind == TypeDeclaration.KIND_ENUM || it.kind == TypeDeclaration.KIND_INPUT_OBJECT_TYPE }

  private fun Map<String, String>.supportedTypeMap(typeDeclarations: List<TypeDeclaration>): Map<String, String> {
    val idScalarTypeMap = ScalarType.ID.name to (this[ScalarType.ID.name] ?: ClassNames.STRING.toString())
    return typeDeclarations.filter { it.kind == TypeDeclaration.KIND_SCALAR_TYPE }
        .associate { it.name to (this[it.name] ?: ClassNames.OBJECT.toString()) }
        .plus(idScalarTypeMap)
  }

  companion object {
    private const val AUTO_GENERATED_FILE = "AUTO-GENERATED FILE. DO NOT MODIFY.\n\n" +
        "This class was automatically generated by Apollo GraphQL plugin from the GraphQL queries it found.\n" +
        "It should not be modified by hand.\n"
  }

  /**
   * For more details about the fields defined here, check the gradle plugin
   */
  data class Arguments(
      val ir: CodeGenerationIR,
      val outputDir: File,
      val customTypeMap: Map<String, String>,
      val operationOutput: OperationOutput,
      val useSemanticNaming: Boolean,
      val generateKotlinModels: Boolean = false,
      val generateAsInternal: Boolean = false,
      // for MPP projects, we add helper code to help with optional and generics
      val kotlinMultiPlatformProject: Boolean = false,
      // if this compilation unit is reusing some fragments and types from another one, use this
      // argument to prevent defining the classes multiple times
      val writeTypes: Boolean,
      // only if generateKotlinModels = true
      val enumAsSealedClassPatternFilters: List<String>,
      // only if generateKotlinModels = false
      val nullableValueType: NullableValueType,
      // only if generateKotlinModels = false
      val generateModelBuilder: Boolean,
      // only if generateKotlinModels = false
      val useJavaBeansSemanticNaming: Boolean,
      // only if generateKotlinModels = false
      val suppressRawTypesWarning: Boolean,
      // only if generateKotlinModels = false
      val generateVisitorForPolymorphicDatatypes: Boolean = false
  )
}
