package com.apollographql.apollo3.compiler

import com.apollographql.apollo3.annotations.ApolloExperimental
import com.apollographql.apollo3.ast.GQLFragmentDefinition
import com.apollographql.apollo3.ast.Schema
import com.apollographql.apollo3.ast.parseAsGQLDocument
import com.apollographql.apollo3.ast.toSchema
import com.apollographql.apollo3.ast.toUtf8
import com.apollographql.apollo3.ast.validateAsSchema
import com.apollographql.apollo3.compiler.codegen.ResolverInfo
import com.squareup.moshi.JsonAdapter
import com.squareup.moshi.JsonClass
import com.squareup.moshi.JsonReader
import com.squareup.moshi.JsonWriter
import com.squareup.moshi.Moshi
import okio.buffer
import okio.sink
import okio.source
import java.io.File

/**
 * metadata generated by a previous run of [ApolloCompiler]. The schema and fragments are stored as GraphQL document strings. This
 * slightly unfortunate because that means we will parse them twice but there isn't many alternatives as validation and IR-building takes
 * GQLDocuments as inputs. A future version could serialize GQLNode as json in order to keep the SourceLocation attributes and display
 * better error messages
 */
@JsonClass(generateAdapter = true)
@OptIn(ApolloExperimental::class)
data class ApolloMetadata(
    /**
     * Only non-null for the root module
     */
    val commonMetadata: CommonMetadata?,
    val compilerMetadata: CompilerMetadata,
    val moduleName: String
) {
  companion object {

    /**
     * A JsonAdapter that will use SDL to serialize Schema and GQLFragmentDefinition
     */
    private val adapter by lazy {
      val schemaJsonAdapter = object : JsonAdapter<Schema>() {
        override fun fromJson(reader: JsonReader): Schema {
          val string = reader.nextString()
          return string.buffer().toSchema()
        }

        override fun toJson(writer: JsonWriter, schema: Schema?) {
          writer.value(schema!!.toGQLDocument().toUtf8())
        }
      }

      val gqlFragmentJsonAdapter = object : JsonAdapter<GQLFragmentDefinition>() {
        override fun fromJson(reader: JsonReader): GQLFragmentDefinition {
          val string = reader.nextString()
          return string.buffer().parseAsGQLDocument().valueAssertNoErrors().definitions.first() as GQLFragmentDefinition
        }

        override fun toJson(writer: JsonWriter, fragmentDefinition: GQLFragmentDefinition?) {
          writer.value(fragmentDefinition!!.toUtf8())
        }
      }

      Moshi.Builder()
          .add(Schema::class.java, schemaJsonAdapter.nullSafe())
          .add(GQLFragmentDefinition::class.java, gqlFragmentJsonAdapter.nonNull())
          .build()
          .adapter(ApolloMetadata::class.java)
    }

    fun readFrom(file: File) = adapter.fromJson(file.source().buffer()) ?: error("bad metadata at ${file.absolutePath}")
  }

  fun writeTo(file: File) {
    file.parentFile.mkdirs()
    file.sink().buffer().use {
      adapter.toJson(it, this)
    }
  }
}

/**
 * Options that must be common to all modules
 */
@JsonClass(generateAdapter = true)
data class CommonMetadata(
    val schema: Schema,
    /**
     * Remember the schema path to retrieve the package name if needed
     */
    val schemaPath: String,
    val pluginVersion: String,
    val codegenModels: String,
)

/**
 * Compilation unit specific metadata that is specific to a given invocation of the compiler
 */
@JsonClass(generateAdapter = true)
data class CompilerMetadata(
    /**
     * The fragments needed:
     * - to validate the operations
     * - to embed the fragment source in the query document
     * - to lookup the super interfaces when generating response-based models
     */
    val fragments: List<GQLFragmentDefinition>,
    /**
     * resolver info used by the codegen to lookup already existing ClassNames
     */
    val resolverInfo: ResolverInfo
)
