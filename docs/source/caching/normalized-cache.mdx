---
title: Normalized cache
---

> This page focuses on the normalized cache. A normalized cache has several advantages like deduplication and watchers. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).


## Data Normalization

A normalized cache stores objects by ID. Instead of caching the whole response, the normalized cache can deduplicate common parts. For an example, take these two queries:

```graphql
query BookWithAuthorName {
  favoriteBook {
    id
    title
    author {
      id
      name
    }
  }
}

query AuthorById($id: String!) {
  author(id: $id) {
      id
      name
    }
  }
}
```

In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This works because the author is stored only once in the cache and all the fields were retrieved in the initial `BookWithAuthorName` query. If you were to request more fields, like `birthdate` for example, that wouldn't work anymore.

Using a normalized cache as several advantages. The main one is to avoid storing duplicate data and save some space. Another big one is that you can use the cache as a single source of truth for your UI and react to changes in the cache. To learn more about the process of normalization, check this [blog post about cache normalization](https://www.apollographql.com/blog/apollo-client/caching/demystifying-cache-normalization/).

## Memory cache

Apollo Android comes with a `MemoryCache` that will store your data in memory. To use it, add the `apollo-normalized-cache` artifact to your dependencies in your `build.gradle[.kts]` file:

```kotlin:title=build.gradle[.kts]
dependencies {
  implementation("com.apollographql.apollo3:apollo-normalized-cache:x.y.z")
}
```

And add it to your `ApolloClient`:

```kotlin
// Create a 10MB MemoryCacheFactory
val cacheFactory = MemoryCacheFactory(maxSizeBytes = 10 * 1024 * 1024)
// Build the ApolloClient
val apolloClient = ApolloClient.Builder()
  .serverUrl("https://...")
  // normalizedCache() is an extension function on ApolloClient.Builder
  .normalizedCache(cacheFactory)
  .build()
```

Because the normalized cache is optional, `normalizedCache()` is an extension function on `ApolloClient.Builder()` that's defined in the `apollo-normalized-cache` artifact. It takes a `NormalizedCacheFactory` as a parameter so that it can create the cache outside the main thread if needed.

A `MemoryCache` is a least recently used (LRU) cache. It keeps entries in memory based on two conditions:

* `maxSizeBytes`: the maximum size in bytes the cache may occupy
* `expireAfterMillis`: after what timeout each entry in the cache treated as expired. By default there is no timeout.

When your app is stopped, data in the `MemoryCache` is lost forever. If you need to persist data, you can use the SQLite cache.

## SQLite cache

The SQLite cache uses [SQLDelight](https://github.com/cashapp/sqldelight) to store data persistently. It can be used when you need to persist data across app restarts or simply if the data becomes too big to fit in memory.

To enable SQLite cache support, add the `apollo-normalized-cache-sqlite` dependency to your project's `build.gradle` file:

```kotlin:title=build.gradle.kts
dependencies {
  implementation("com.apollographql.apollo3:apollo-normalized-cache-sqlite:x.y.z")
}
```

And add the SQLite cache to your `ApolloClient`. Because different platforms use different drivers, you'll need to call the platform specific constructor:

```kotlin
// Android
val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(context, "apollo.db")
// JVM
val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory("jdbc:sqlite:apollo.db")
// iOS
val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory("apollo.db")

// Build the ApolloClient
val apolloClient = ApolloClient.Builder()
  .serverUrl("https://...")
  .normalizedCache(sqlNormalizedCacheFactory)
  .build()
```

You can then use it like the `MemoryCache`.


## Chaining caches

To get the best of both caches, you can chain a `MemoryCacheFactory` with a `SqlNormalizedCacheFactory`:

```kotlin

val memoryFirstThenSqlCacheFactory = MemoryCacheFactory(10 * 1024 * 1024)
  .chain(SqlNormalizedCacheFactory(context, "db_name"))

```

Reads will return the first cache hit in the chain. Writes will propagate down the entire chain.

## Getting data from the cache

Once your cache setup is complete, the cache will be used by default by all your queries. By default, queries will try to find a result in the cache first and go the network if it's not there. This is the `FetchPolicy.CacheFirst`. You can customize that behaviour with `fetchPolicy(FetchPolicy)`:

```kotlin
val response = apolloClient.query(query)
                 // Don't use the cache at all
                 .fetchPolicy(FetchPolicy.NetworkOnly)

                 // Or use only the cache
                 .fetchPolicy(FetchPolicy.CacheOnly)

                 // Or use the cache only if the network fails
                 .fetchPolicy(FetchPolicy.NetworkFirst)

                 // Or use the network only if the cache fails (default)
                 .fetchPolicy(FetchPolicy.CacheFirst)

                 // In all cases, execute your query
                 .execute()
```

Like for `normalizedCache(NormalizedCacheFactory)`, `fetchPolicy(FetchPolicy)` is an extension function on `ApolloClient.Builder()` so you will need `apollo-normalized-cache` in your classpath for this to work.

Because the normalized cache deduplicates all your data, it allows to react to cache changes. This is done with `watchers` that listen to cache changes. You can learn more about them [in this page](query-watchers). Using watchers requires deduplicating your objects by specifying their object ids.

## Specifying your object IDs

By default, Apollo Android uses the field path as key to store data. Back to the original example:

```graphql
query BookWithAuthorName {
  favoriteBook {
    id
    title
    author {
      id
      name
    }
  }
}

query AuthorById($id: String!) {
  author(id: $id) {
      id
      name
    }
  }
}
```

This will store the following records:

```
* "favoriteBook": {"id": "book1", "title": "Les guerriers du silence", "author": "CacheKey{favoriteBook.author}"}
* "favoriteBook.author": {"id": "author1", name": "Pierre Bordage"}
* "author("id": "author1")": {"id": "author1", "name": "Pierre Bordage"}
* "QUERY_ROOT": {"favoriteBook": "CacheKey{favoriteBook}", "author(\"id\": \"author1\")": "CacheKey{author(\"id\": \"author1\")}"}
```

This is undesirable, both because it takes more space, and because modifying one of those objects will not notify the watchers of the other. What you want instead is this:

```
* "book1"`: `{"id": "book1", "title": "Les guerriers du silence", "author": "CacheKey{author1}"}
* "author1"`: `{"id": "author1", name": "Pierre Bordage"}
* "QUERY_ROOT"`: `{"favoriteBook": "CacheKey(book1)", "author(\"id\": \"author1\")": "CacheKey(author1)"}
```

The good news is that all your objects have an `id` field that we can use for that purpose. If each `id` is unique across the whole graph, you can use it directly. If it's unique per object type, you can prefix it with the type name. For an example: `"Book:$id"`.

Note how `id` can be computed from two sources:

1. From the object fields (`author.id`)
2. From a field arguments (`author(id)`)


1. is happening **after** a network request and is important to merge the network response with existing data. This is the most usual case.
2. is happening **before** a network request and is important to avoid a network round trip if all the data is in the cache already. This is an optimization that can avoid some cache misses.

To instruct the cache how to compute the `id` field in both cases, you have two solutions:

* [The declarative way](declarative-ids) (preferred): you can specify schema extensions that tell the codegen where to find the id and make sure at compile time that all the `id` fields are requested so that all objects can be identified. Declarative ids will also prefix each id with the typename to ensure globally unique ids.
* [The programmatic way](programmatic-ids): you can implement APIs that will retrieve the id for an object. Because you can execute arbitrary code, this solution is more flexible but it's also more error prone and requires that you manually request `id` fields .
