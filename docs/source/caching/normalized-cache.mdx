---
title: Normalized cache
---

> This page focuses on the normalized cache. If you're looking for a simpler albeit coarser cache, take a look at the [HTTP cache](http-cache).



## Data Normalization

A normalized cache stores objects by ID. Instead of caching the whole response, the normalized cache can deduplicate common parts:

```graphql
query BookWithAuthorName {
  favoriteBook {
    id
    title
    author {
      id
      name
    }
  }
}

query AuthorById($id: String!) {
  author(id: $id) {
      id
      name
    }
  }
}
```

In the above example, requesting the author of your favorite book with the `AuthorById` query will return a result from the cache if you requested your favorite book before. This works because the author is stored only once in the cache and all the fields were retrieved in the initial `BookWithAuthorName` query. If you were to request more fields, like `birthdate` for example, that wouldn't work anymore.

Using a normalized cache as several advantages. The main one is to avoid storing duplicate data and save some space. Another big one is that you can use the cache as a single source of truth for your UI and react to changes in the cache. To learn more about the process of normalization, check this [blog post about cache normalization](https://www.apollographql.com/blog/apollo-client/caching/demystifying-cache-normalization/).

## Memory cache

Apollo Android comes with a `MemoryCache` that will store your data in memory. To use it, add it to your dependencies in your `build.gradle[.kts]` script:

```kotlin
dependencies {
  implementation("com.apollographql.apollo3:apollo-normalized-cache:x.y.z")
}
```

And add it to your `ApolloClient`:

```kotlin
// Build the ApolloClient
val apolloClient = ApolloClient.Builder()
  .serverUrl("https://...")
  // Create a 10MB MemoryCacheFactory
  .normalizedCache(MemoryCacheFactory(maxSizeBytes = 10 * 1024 * 1024))
  .build()
```

`normalizedCache()` takes a `NormalizedCacheFactory` as a parameter so that it can create the cache in the background. This is not a big issue for a memory cache but it could be for a SQLite cache.

A `MemoryCache` is least recently used (LRU) cache. It keeps entries in memory based on two conditions:

* `maxSizeBytes`: the maximum size in bytes the cache may occupy
* `expireAfterMillis` - after what timeout each entry in the cache treated as expired. By default there is no timeout.

When your app is stopped, data in the `MemoryCache` is lost forever. If you need to persist data, Apollo Android also supports a SQLite cache

## SQLite cache

If the amount of data you store becomes too big to fit in memory or if you want your data to persist between app restarts, you can also use a `SqlNormalizedCacheFactory`. A `SqlNormalizedCacheFactory` will store your data in a [SQLDelight](https://github.com/cashapp/sqldelight) database and is defined in a separate dependency:

```kotlin:title=build.gradle.kts
dependencies {
  implementation("com.apollographql.apollo3:apollo-normalized-cache-sqlite:x.y.z")
}
```

And add the SQLite cache to your `ApolloClient`:

```kotlin
// Android
val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory(context, "apollo.db")
// JVM
val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory("jdbc:sqlite:apollo.db")
// iOS
val sqlNormalizedCacheFactory = SqlNormalizedCacheFactory("apollo.db")

// Build the ApolloClient
val apolloClient = ApolloClient.Builder()
  .serverUrl("https://...")
  .normalizedCache(sqlNormalizedCacheFactory)
  .build()
```

Because different platform use different drivers, you'll need to call the platform specific constructor.

## Chaining caches

To get the best of both caches, you can chain an `MemoryCacheFactory` with a `SqlNormalizedCacheFactory`:

```kotlin

val memoryFirstThenSqlCacheFactory = MemoryCacheFactory(10 * 1024 * 1024)
  .chain(SqlNormalizedCacheFactory(context, "db_name"))

```

Reads will read from the first cache hit in the chain. Writes will propagate down the entire chain.

## Specifying your object IDs

By default, Apollo Android uses the field path as key to store data. Back to the original example:

```graphl
query BookWithAuthorName {
  favoriteBook {
    id
    title
    author {
      id
      name
    }
  }
}

query AuthorById($id: String!) {
  author(id: $id) {
      id
      name
    }
  }
}
```

This will store the following records:

* `"favoriteBook"`: `{"id": "book1", "title": "Les guerriers du silence", "author": "ApolloCacheReference{favoriteBook.author}"}`
* `"favoriteBook.author"`: `{"id": "author1", name": "Pierre Bordage"}`
* `"author("id": "author1")"`: `{"id": "author1", "name": "Pierre Bordage"}`
* `"QUERY_ROOT"`: `{"favoriteBook": "ApolloCacheReference{favoriteBook}", "author(\"id\": \"author1\")": "ApolloCacheReference{author(\"id\": \"author1\")}"}`

This is undesirable, both because it takes more space, and because modifying one of those objects will not notify the watchers of the other. What you want instead is this:

* `"book1"`: `{"id": "book1", "title": "Les guerriers du silence", "author": "ApolloCacheReference{author1}"}`
* `"author1"`: `{"id": "author1", name": "Pierre Bordage"}`
* `"QUERY_ROOT"`: `{"favoriteBook": "book1", "author(\"id\": \"author1\")": "author1"}`

The good news is that all your objects have an `id` field that we can use for that purpose. If each `id` is unique across the whole graph, you can use it directly. If it's unique per object type, you can prefix it with the type name. For an example: `"Book:$id"`.

Note how `id` can be used in two places:
1. As an object field (`author.id`)
2. As a field argument (`author(id)`)

1. is happening **after** a network request and is important to merge the network response with existing data. This is the most usual case.
2. is happening **before** a network request and is important to avoid a network round trip if all the data is in the cache already. This is an optimization that can avoid some cache misses.

To instruct the cache how to compute the `id` field in both cases, you have two solutions:

* [The declarative way](declarative-ids) (preferred): you can specify schema extensions that tell the codegen where to find the id and make sure at compile time that all the `id` fields are requested so that all objects can be identified. Declarative ids will also prefix each id with the typename to ensure globally unique ids.
* [The programmatic way](programmatic-ids): you can implement APIs that will retrieve the id for an object. Because you can execute arbitrary code, this solution is more flexible but it's also more error prone and requires that you manually request `id` fields .
