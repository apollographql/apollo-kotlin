---
title: Migrating to Apollo Android 3.0
description: From 2.x
sidebar_title: "Migrating to v3"
---

import {MultiCodeBlock} from 'gatsby-theme-apollo-docs';

Apollo Android 3.0 rewrites most of Apollo Android's internals in Kotlin. Among other improvements, it features:

* Kotlin-first, coroutine-based APIs
* A unified runtime for both JVM and multiplatform

Although most of the library's concepts are the same, many APIs have changed to work better in Kotlin.

This page describes the most important changes, along with how to migrate an existing project from Apollo Android 2.x to Apollo Android 3.x.

## Package name / group id / plugin id

Apollo Android 3.0 uses a new identifier for its package name, Gradle plugin id, and maven group id: **`com.apollographql.apollo3`**.

This change helps avoid dependency conflicts and conflicting classes in the classpath, as encouraged in [Java Interoperability Policy for Major Version Updates](https://jakewharton.com/java-interoperability-policy-for-major-version-updates/).

> In most cases, you can update identifier throughout your project by performing a find-and-replace on the 2.x identifier, `com.apollographql.apollo`.

#### Group id

The maven group id used to identify Apollo Android 3.0 [artifacts](https://repo1.maven.org/maven2/com/apollographql/apollo3/) is `com.apollographql.apollo3`:

```kotlin
// Replace:
implementation("com.apollographql.apollo:apollo-runtime:$version")
implementation("com.apollographql.apollo:apollo-api:$version")

// With:
implementation("com.apollographql.apollo3:apollo-runtime:$version")
implementation("com.apollographql.apollo3:apollo-api:$version")
```

#### Gradle plugin id

The Apollo Android 3.0 Gradle plugin id is `com.apollographql.apollo3`:

```kotlin
// Replace:
plugins {
  id("com.apollographql.apollo").version("$version")
}

// With:
plugins {
  id("com.apollographql.apollo3").version("$version")
}
```

#### Package name

All Apollo Android 3.0 classes are imported from the `com.apollographql.apollo3` package:

```kotlin
// Replace:
import com.apollographql.apollo.ApolloClient

// With:
import com.apollographql.apollo3.ApolloClient
```

## Gradle configuration

### `generateKotlinModels`

Apollo Android 3.0 generates Kotlin models by default. You can safely remove this behavior:

```kotlin
apollo {
  // remove this
  generateKotlinModels.set(true)
}
```

> At the time of writing, Java codegen is not working but will be added in a future update. For details, see [this GitHub issue](https://github.com/apollographql/apollo-android/issues/2616).

### `customScalarMappings`

In order to make it explicit that custom mappings only apply to custom scalars and not arbitrary types, `customTypeMapping` has been renamed to `customScalarsMapping`

<MultiCodeBlock>

```groovy
apollo {
  // Replace
  customTypeMapping = [
    "GeoPoint" : "com.example.GeoPoint"
  ]
  // With
  customScalarsMapping = [
    "GeoPoint" : "com.example.GeoPoint"
  ]
}
```

```kotlin
apollo {
  // Replace
  customTypeMapping.set(mapOf(
    "GeoPoint" to "com.example.GeoPoint"
  ))
  // With
  customScalarsMapping.set(mapOf(
    "GeoPoint" to "com.example.GeoPoint"
  ))
}
```

</MultiCodeBlock>

### Target package name

Apollo Android 2.x computes its target package name based on a combination of uses the file path of GraphQL operation and schema files as well as `packageName` and `rootPackageName` options to compute the target package name. While this is very flexible, it's not easy to anticipate the final package name that is going to be used.

Apollo Android 3.x uses a flat package name by default using the `packageName` option:

```kotlin
apollo {
  packageName.set("com.example")
}
```

The generated classes will be:

```
- com.example.SomeQuery
- com.example.fragment.SomeFragment
- com.example.type.SomeInputObject
- com.example.type.SomeEnum
- com.example.type.Types // types is a slimmed down version of the schema
```

If you need different package names for different operation folders, you can fallback to the 2.x behaviour with:

```kotlin
apollo {
  filePathAwarePackageNameGenerator("$rootPackageName")
}
```

For even more control, you can also define your own `PackageNameGenerator`:

```kotlin
apollo {
  packageNameGenerator.set(customPackageNameGenerator)
}
```

### Removed `CompilationUnit`s

Apollo Android 2.x creates multiple `CompilationUnit`s for different Android variants or different Kotlin source sets. This runs the GraphQL compiler multiple times. For example, Android compilation generates GraphQL classes at least twice (once for the debug build and once for the release build). In most cases, the generated classes are identical and this needlessly increases build time.

Apollo Android 3.x removes `CompilationUnit`s. Instead, each `Service` is exactly one compilation. For Android projects, GraphQL classes are generated once and then added to all variants.

If you need different GraphQL operations for different variants, you can create multiple services for each Android variant like so:

```kotlin
apollo {
  createAllAndroidVariantServices(
    sourceFolder = "starwars", // will look into src/main/graphql/starwars, src/debug/graphql/starwars, etc
    nameSuffix = "starwars", // will create tasks named generateDebugStarwarsApolloSources, generateReleaseStarwarsApolloSources, etc.
  ) {
    // configure your service here
  }
}
```

If you previously used `graphqlSourceDirectorySet` to explicitely specify the location of GraphQL files, you can now use `srcDir`:


```kotlin
apollo {
  // Replace
  graphqlSourceDirectorySet.srcDirs += "shared/graphql"

  // With
  srcDir("shared/graphql")
}
```

## Constructors

Apollo Android 2.x uses the `Builder` pattern in various places to create new instances.

Apollo Android 3.x instead uses Kotlin default arguments and exposes constructors as top-level functions.

For example, for `ApolloClient`:

```kotlin
// Replace
val apolloClient = ApolloClient.builder()
    .serverUrl("https://apollo-fullstack-tutorial.herokuapp.com")
    .build()

// With
val apolloClient = ApolloClient(serverUrl = "https://apollo-fullstack-tutorial.herokuapp.com")
```

To customize the `OkHttpClient`:

```kotlin
// Replace
val apolloClient = ApolloClient.builder()
    .serverUrl(serverUrl)
    .okHttpClient(okHttpClient)
    .build()

// With
val apolloClient = ApolloClient(
  networkTransport = HttpNetworkTransport(
    server = serverUrl,
    engine = DefaultHttpEngine(okHttpClient = okHttpClient)
  )
)
```

## Coroutines APIs

Apollo Android 2.x has callback APIs that can become verbose and require explicitely handling cancellation.

Apollo Android 3.x exposes more concise coroutines APIs that handle cancellation automatically through the coroutine scope.

```kotlin
// Replace
apolloClient.query(query).await()
// With
apolloClient.query(query)

// Replace
apolloClient.subscribe(subscription).toFlow()
// With
apolloClient.subscribe(subscription)
```

## Custom Scalar adapters

The Custom Scalar adapters API has changed a lot to support nullable and absent values as well as streaming use cases. It now uses the same `Adapter` API that is used internally to parse the models:

```kotlin
// Replace
val dateAdapter = object : CustomTypeAdapter<Date> {
  override fun decode(value: CustomTypeValue<*>): Date {
    DATE_FORMAT.parse(value.value.toString())
  }

  override fun encode(value: Date): CustomTypeValue<*> {
    return GraphQLString(DATE_FORMAT.format(value))
  }
}

// With
val dateAdapter = object : Adapter<Date> {
  override fun fromJson(reader: JsonReader, customScalarAdapters: CustomScalarAdapters): Date {
    return DATE_FORMAT.parse(reader.nextString())
  }

  override fun toJson(writer: JsonWriter, customScalarAdapters: CustomScalarAdapters, value: Date) {
    writer.value(DATE_FORMAT.format(value))
  }
}
```

The `JsonReader` and `JsonWriter` APIs are similar to the ones you can find in [Moshi](https://github.com/square/moshi) and are stateful APIs that require you to handle the Json properties in the order they arrive from the Json stream. If you prefer, you can also buffer the Json into an untyped `Any?` value that represent the json and use `AnyAdapter` to decode/encode it:

```kotlin
// Use AnyAdapter to convert between JsonReader/JsonWriter and a Kotlin Any value
val geoPointAdapter = object : Adapter<GeoPoint> {
  override fun fromJson(reader: JsonReader, customScalarAdapters: CustomScalarAdapters): GeoPoint {
    val map = AnyAdapter.fromJson(reader) as Map<String, Double>
    return GeoPoint(map["latitude"] as Double, map["longitude"] as Double)
  }

  override fun toJson(writer: JsonWriter, customScalarAdapters: CustomScalarAdapters, value: GeoPoint) {
    val map = mapOf(
        "latitude" to value.latitude,
        "longitude" to value.longitude
    )
    AnyAdapter.toJson(writer, map)
  }
}
```

After you define your adapters, you need to register them with your `ApolloClient` instance. To do so, call `ApolloClient.withCustomScalarAdapter` once for each adapter:

```kotlin
// Replace
val apolloClient = apolloClientBuilder.addCustomTypeAdapter(CustomType.DATE, dateAdapter).build()

// With
val apolloClient = ApolloClient("https://..").withCustomScalarAdapter(Types.Date, dateAdapter)
```

This method takes a type-safe generated class from `Types`, along with its corresponding adapter.


## Caching

### Normalized cache

The Apollo Android 2.x runtime has a dependency on the normalized cache APIs, and it's possible to call cache methods even if no cache implementation is in the classpath.

The Apollo Android 3.x runtime is more modular and doesn't know anything about normalized cache by default. To add normalized cache support, include `apollo-normalized-cache` in the classpath:

```kotlin
dependencies {
  // Replace
  implementation("com.apollographql.apollo:apollo-normalized-cache") // for memory cache
  implementation("com.apollographql.apollo:apollo-normalized-cache-sqlite") // for SQL cache

  // With
  implementation("com.apollographql.apollo3:apollo-normalized-cache") // for memory cache
  implementation("com.apollographql.apollo3:apollo-normalized-cache-sqlite") // for SQL cache
}
```

```kotlin
// Replace
val cacheFactory = LruNormalizedCacheFactory(
                     EvictionPolicy.builder().maxSizeBytes(10 * 1024 * 1024).build()
                   )

val apolloClient = ApolloClient.builder()
  .serverUrl("https://...")
  .normalizedCache(cacheFactory)
  .build())

// With
val cacheFactory = MemoryCacheFactory(maxSizeBytes = 10 * 1024 * 1024)
val apolloClient = ApolloClient("https://...")
                      .withNormalizedCache(cacheFactory)
```

Configuring the fetch policy is now made on an `ApolloRequest` instance:

```kotlin
// Replace
val response = apolloClient.query(query)
                      .toBuilder()
                      .responseFetcher(ApolloResponseFetchers.CACHE_FIRST)
                      .build()
                      .await()

// With
val request = ApolloRequest(query).withFetchPolicy(CacheFirst)
val response = apolloClient.query(request)
```

### HTTP cache

Similarly, the HTTP cache is configurable through extension functions:

```kotlin
// Replace
val cacheStore = DiskLruHttpCacheStore()
val apolloClient = ApolloClient.builder()
    .serverUrl("/")
    .httpCache(ApolloHttpCache(cacheStore))
    .build()

// With
val apolloClient = ApolloClient("https://...")
                      .withHttpCache(File(cacheDir, "apolloCache"), 1024 * 1024)
```

Configuring the HTTP fetch policy is now made on an `ApolloRequest` instance:

```kotlin
// Replace
val response = apolloClient.query(query)
                      .toBuilder()
                      .httpCachePolicy(HttpCachePolicy.CACHE_FIRST)
                      .build()
                      .await()

// With
val request = ApolloRequest(query).withHttpFetchPolicy(CacheFirst)
val response = apolloClient.query(request)
```

### `CacheKeyResolver`

The `CacheKeyResolver` API has been updated to work with declarative cache.

* `fromFieldRecordSet` is renamed to `cacheKeyForObject`.
* `fromFieldArguments` is renamed to `cacheKeyForField`.
* The `CacheKey` return value is now nullable, and `CacheKey.NONE` is replaced with `null`.

```kotlin
// Replace
val resolver: CacheKeyResolver = object : CacheKeyResolver() {
  override fun fromFieldRecordSet(field: ResponseField, recordSet: Map<String, Any>): CacheKey {
    return CacheKey.from(recordSet["id"] as String)
  }
  override fun fromFieldArguments(field: ResponseField, variables: Operation.Variables): CacheKey {
    return CacheKey.from(field.resolveArgument("id", variables) as String)
  }
}

// With
val cacheKeyResolver = object : CacheKeyResolver() {
  override fun cacheKeyForObject(type: CompiledNamedType, variables: Executable.Variables, obj: Map<String, Any?>): CacheKey? {
    return (obj["id"] as? String)?.let { CacheKey(it) }
  }
  override fun cacheKeyForField(field: CompiledField, variables: Executable.Variables): CacheKey? {
    return (field.resolveArgument("id", variables) as? String)?.let { CacheKey(it) }
  }
}
```

## Optional values

### The `Optional` class

Apollo Android distinguishes between `null` values and absent values.

Apollo Android 2.x uses `Input` to represent optional (maybe nullable) values for input types.

Apollo Android 3.x uses `Optional` instead so that later it can potentially be used in places _besides_ input types (for example, fields could be made optional with an [`@optional`](https://github.com/apollographql/apollo-android/blob/5c1ff82ccaded93ae7126cedc6d7835e63fed75a/apollo-compiler/src/main/resources/apollo.graphqls#L6) directive).

`Optional` is a sealed class, so `when` statements don't need an `else` branch.


```kotlin
// Replace
Input.fromNullable(value)
// With
Optional.Present(value)

// Replace
Input.absent()
// With
Optional.Absent

// Replace
Input.optional(value)
// With
Optional.presentIfNotNull(value)
```

### Non-optional variables by default

By default, Apollo Android 3.x represents operation variables that _don't_ have a default value as non-optional Kotlin constructor parameters.

Given the following query:

```graphql
query GetHero($id: String) {
  hero(id: $id)
}
```

Apollo Android generates:

```kotlin
// 2.x
class GetHero(val id: Input<String?> = Input.absent())

// 3.x
class GetHero(val id: String?)
```

By default, the [GraphQL spec](https://spec.graphql.org/draft/#sec-Coercing-Variable-Values) treats nullable variables as optional, so it's valid to omit them at runtime. In practice, however, this is rarely used and makes the operation's declaration verbose.

Apollo Android 3.x removes the `Optional` wrapper so that it's more straightforward to construct a query with nullable variables.

> This new behavior applies _only_ to variables. Fields of input objects still use `Optional`, because it's common to omit particular input fields.

If you want to be able to omit a variable, you can opt in to the `Optional` wrapper with the `@optional` directive:

```graphql
query GetHero($id: String @optional) {
  hero(id: $id)
}
```

## Enums

By default, Apollo Android 2.x generates GraphQL enums as Kotlin enums, with an option to generate them as sealed classes to access the raw name of the enum.

Apollo Android 3.x drops Kotlin enums and always generates sealed classes. In addition, Apollo Android 3.x uses the same case for enum names as their GraphQL definition, instead of converting them to uppercase. This enables you to define different enums with different cases, which is valid in GraphQL.
