---
title: Migrating to Apollo Kotlin 5
subtitle: Step-by-step guide on migrating from Apollo Kotlin 4
description: Learn how to migrate from version 4 with key changes, new features, and tools designed for improved stability and maintainability. Follow step-by-step guidance and make a seamless transition
---

Apollo Kotlin 5 is an incremental evolution of Apollo Kotlin 4 and keeps the same package name. 

In most cases, bumping the version should be transparent. The exceptions are:

- Symbols that were `DeprecationLevel.ERROR` in v4 are now removed. Remove all your deprecated usages before migrating to v5.
- `apollo-compiler` is still considered experimental. You will need to update your [Apollo Compiler Plugins](https://www.apollographql.com/docs/kotlin/advanced/compiler-plugins). 

We tried hard to minimize the impact of the binary changes so that running code compiled for v4 will run with v5. But the occasional incompatibility may happen. In that case, the incompatible libraries will need to compile against v5 and make a new release.   

## Removed `apollo-gradle-plugin-external` and `com.apollographql.apollo.external`

The Apollo Gradle Plugin [now uses classloader isolation](https://github.com/apollographql/apollo-kotlin/pull/6524) and does not use R8 to relocate dependencies anymore. As a result, the `apollo-gradle-plugin-external` artifact and the `com.apollographql.apollo.external` plugins have been removed. You should use `apollo-gradle-plugin` and `com.apollographql.apollo` instead:

```kotlin
// Replace
implementation("com.apollographql.apollo:apollo-gradle-plugin-external:4.3.3")
// With 
implementation("com.apollographql.apollo:apollo-gradle-plugin:4.3.3")

plugins {
  // Replace
  id("com.apollographql.apollo.external")
  // With 
  id("com.apollographql.apollo")
}
```

## Removed `Service.operationOutputGenerator` and `Service.operationIdGenerator`

While running your `OperationOutputGenerator` directly in your build script classpath was convenient, it required the compiler code to run completely in the global buildscript classpath. This created numerous issues such as incompatible dependencies and/or unneeded build invalidations.

To mitigate the impact of incompatible dependencies, Apollo Kotlin 4 used to shadow and relocate all its dependencies, which came with additional issues: increased build times, weird stack traces and larger plugin size.

Apollo Kotlin v5 instead runs its compiler in isolated classloaders, meaning generating the ids now needs to happen in that same classloader. 

To do so, use `ApolloCompilerPlugin`:

```kotlin
class MyPlugin : ApolloCompilerPlugin {
  override fun beforeCompilationStep(
      environment: ApolloCompilerPluginEnvironment,
      registry: ApolloCompilerRegistry,
  ) {
    registry.registerOperationIdsGenerator {
      it.map { OperationId(it.source.md5(), it.name) }
    }
  }
}
```

Read more in the [persisted queries](https://www.apollographql.com/docs/kotlin/v5/advanced/persisted-queries) and [compiler plugins](https://www.apollographql.com/docs/kotlin/v5/advanced/compiler-plugins) pages.


## Removed ApolloIdlingResource

Apollo Kotlin 5 removes `ApolloIdlingResource`. `IdlingResource` usage has been slowly decreasing and there are now better alternatives to do your testing.

For a good overview of alternative solutions, we recommend [this article from Jose Alc√©rreca](https://medium.com/androiddevelopers/alternatives-to-idling-resources-in-compose-tests-8ae71f9fc473).

## Using `@nonnull` is now an error

Apollo Kotlin 4 had a `@nonnull` client directive to force generating fields as non-null.

Since `@nonnull`, we've worked hard with the [nullability working group](https://github.com/graphql/nullability-wg/) to improve the handling of null types in GraphQL.

As part of this effort, it was recognized that the nullability information belongs to the schema. Fields that are only nullable for error reasons can now be marked with `@semanticNonNull`:

```graphql
type User {
  email: String @semanticNonNull
}

# or if you don't own the schema, use extensions
extend type User @semanticNonNullField(name: "email")
```

The client can then decide how to handle errors with `@catch`:

```graphql
query GetUser {
  user {
    # generated as `String?` (current default)
    email @catch(to: NULL)
    # generated as `Result<String, Error>`
    email @catch(to: RESULT)
    # generated as `String`, throws if there is an error
    email @catch(to: THROW)
  }
}
```

You can read more in the ["handling nullability" page](https://www.apollographql.com/docs/kotlin/advanced/nullability).


## `apollo-http-cache` is deprecated

Apollo Kotlin 5 removes the `apollo-http-cache` artifact. Instead, it leverages the existing OkHttp cache using [cacheUrlOverride](https://square.github.io/okhttp/5.x/okhttp/okhttp3/-request/-builder/cache-url-override.html).

You can remove the `apollo-http-cache` artifact:

```kotlin
dependencies {
  // Remove
  implementation("com.apollographql.apollo:apollo-http-cache:4.3.3")
}
```

And configure your `ApolloClient` with a cache-enabled `OkHttpClient` and `cachePostResponses`:

```kotlin
// Replace
val apolloClient = ApolloClient.Builder()
    .serverUrl(mockServer.url())
    .httpCache(directory = "http_cache", maxSize = 10_000_000)
    .build()

// With
val apolloClient = ApolloClient.Builder()
    .networkTransport(
        HttpNetworkTransport.Builder()
            // Enable POST caching
            .httpRequestComposer(DefaultHttpRequestComposer(serverUrl = mockServer.url(), enablePostCaching = true))
            .httpEngine(
                DefaultHttpEngine {
                  OkHttpClient.Builder()
                      // Make sure to use a different directory for your cache
                      .cache(directory = "http_cache2", maxSize = 10_000_000)
                      .build()
                }
            )
            .build()
    )
    .build()
```

The OkHttp cache uses `Cache-Control` HTTP headers and has different semantics compared to Apollo Kotlin 4 `HttpFetchPolicy` but most of them using the rules below:

**CacheFirst**:
```kotlin
// Replace 
apolloClient.query(query).httpFetchPolicy(HttpFetchPolicy.CacheFirst)

// With
apolloClient.query(query) // no need to add a cache-control header, this is the default
```

**CacheOnly**:
```kotlin
// Replace 
apolloClient.query(query).httpFetchPolicy(HttpFetchPolicy.CacheOnly)

// With
apolloClient.query(query).addHttpHeader("cache-control", "only-if-cached")
```

**NetworkOnly**:
```kotlin
// Replace
apolloClient.query(query).httpFetchPolicy(HttpFetchPolicy.CacheOnly)

// With
apolloClient.query(query).addHttpHeader("cache-control", "no-cache")
```

### Limitations

While we believe this new caching scheme is simpler and more aligned with the rest of the ecosystem, there are important differences with the previous scheme:

* There is no equivalent to `NetworkFirst` and/or `httpExpireTimeout()`.
* The cache keys have changed, meaning your cache will be invalidated.

If any of those is important for your use case, please [open an issue](https://github.com/apollographql/apollo-kotlin/issues/new). 