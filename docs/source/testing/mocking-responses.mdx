---
title: Mocking responses
---

Apollo Kotlin provides the following tools for mocking responses in tests:

- `TestNetworkTransport`: enables you to specify the GraphQL responses returned by `ApolloClient`
- `MockServer`: a low-level HTTP server that you can use to mock _any_ responses

In most cases, `TestNetworkTransport` is more straightforward to use in your tests, whereas `MockServer` can be useful for testing specific server behavior, such as error cases, custom headers, and timeouts.

## `TestNetworkTransport`

This is a high-level test API that enables you to specify the GraphQL responses that are returned by your `ApolloClient` instance.

Add the dependency to your project's `build.gradle` file:

```kotlin:title=build.gradle[.kts]
dependencies {
  testImplementation("com.apollographql.apollo3:apollo-testing-support:x.y.z")
}
```

Enable the `TestNetworkTransport` by passing it to the `ApolloClient` builder:

```kotlin{2}
val apolloClient = ApolloClient.Builder()
    .networkTransport(TestNetworkTransport())
    .build()
```

Either keep a reference to the `TestNetworkTransport` instance, or use the `testNetworkTransport` extension function to
retrieve it:

```kotlin
val testNetworkTransport = apolloClient.testNetworkTransport
```

You can then use the `register` function to specify the responses that are returned for corresponding operations:

```kotlin{7}
val query = GetHeroQuery("001")
val testData = GetHeroQuery.Data {
  hero = droidHero {
    name = "R2D2"
  }
}
apolloClient.testNetworkTransport.register(query, testData)

val actual = apolloClient.query(query).execute().data!!
assertEquals(testData.hero.name, actual.hero.name)
```

The `register` function accepts an `Operation` (here, the query) and the `ApolloResponse` to return when that operation executes. As a shortcut, you can pass a `Data` directly instead of an `ApolloResponse`, as shown in the example above.

> To help create your mocked response data, you can use [test builders](./test-builders/).

### Advanced usage

In some cases, you might want to return _different_ responses for the _same_ operation if it's executed multiple times.

To achieve this, instead of mapping operations to responses with `register`, you can **enqueue** a list of responses. When you do, these responses are returned in the order they were added.

To enqueue operations, pass a `QueueTestNetworkTransportHandler` to
the `TestNetworkTransport` and call its `enqueue` function:

```kotlin
val handler = QueueTestNetworkTransportHandler()
apolloClient = ApolloClient.Builder().networkTransport(TestNetworkTransport(handler)).build()

handler.enqueue(query, testData1)
handler.enqueue(query, testData2)
handler.enqueue(query, testData3)

val actual1 = apolloClient.query(query).execute().data
val actual2 = apolloClient.query(query).execute().data
val actual3 = apolloClient.query(query).execute().data
```

Note that you need to pass an operation to `enqueue`. This is because an `ApolloResponse` is built under the hood, which has a reference to an operation. There is also a version of `enqueue` that takes only an `ApoolloResponse` as a parameter.

If you need more control over the responses to return, you can implement your own `TestNetworkTransportHandler` and pass it to the `TestNetworkTransport`:

```kotlin
class CustomTestNetworkTransportHandler : TestNetworkTransportHandler {
  override fun handle(request: ApolloRequest<*>): ApolloResponse<*> {
    return ApolloResponse.Builder(
        /* Your custom logic here */
    ).build()
  }
}

apolloClient = ApolloClient.Builder()
    .networkTransport(TestNetworkTransport(CustomTestNetworkTransportHandler()))
    .build()
```

## `MockServer`

While `TestNetworkTransport` handles mocking at the GraphQL level, `MockServer` resides at the HTTP level and can mock arbitrary HTTP responses.

Add the dependency to your project's `build.gradle` file:

```kotlin:title=build.gradle[.kts]
dependencies {
  testImplementation("com.apollographql.apollo3:apollo-mockserver:x.y.z")
}
```

And here's how to use it:

```kotlin
// Create a mock server
val mockServer = MockServer()

// Use its URL on your ApolloClient
val apolloClient = ApolloClient.Builder().serverUrl(mockServer.url()).store(store).build()

// Enqueue responses
mockServer.enqueue("""{"data": {"random": 42}}""")
mockServer.enqueue(
    MockResponse(
        body = "Internal server error",
        statusCode = 500,
        headers = mapOf("X-Test" to "true"),
        delayMillis = 1000L,
    )
)

// Execute queries
val response1 = apolloClient
    .query(GetRandomQuery())
    .execute()

val response2 = apolloClient
    .query(GetRandomQuery())
    .execute()

// Don't forget to stop the server when you're done
mockServer.stop()
```

Note how the `enqueue` function normally takes a `MockResponse` as a parameter, while a shorthand version that takes a `String` also exists.

Also note that you can pass a delay to the `MockResponse` constructor to simulate network latency.

### Advanced usage

By default, `MockServer` is configured with a `QueueMockServerHandler`, which will returns responses in the order they're added. If you need more control over the responses to return, you can implement your own `MockServerHandler` and pass it to the `MockServer`:

```kotlin
val customHandler = object : MockServerHandler {
  override fun handle(request: MockRequest): MockResponse {
    return if (/* Your custom logic here */) {
      MockResponse(
          body = """{"data": {"random": 42}}""",
          headers = mapOf("X-Test" to "true"),
      )
    } else {
      MockResponse(
          body = "Internal server error",
          statusCode = 500,
      )
    }
  }
}

val mockServer = MockServer(customHandler)
```

Note that if you use a custom `MockServerHandler`, calling `MockServer.enqueue()` is no longer possible because it expects the handler to be
a `QueueMockServerHandler`.
