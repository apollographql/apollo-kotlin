---
title: Mocking responses
---

Apollo Kotlin provides the following tools for mocking responses in tests:

- `TestNetworkTransport`: enables you to specify the GraphQL responses returned by `ApolloClient`
- `MockServer`: a low-level HTTP server that you can use to mock _any_ responses

`MockServer` creates a full HTTP server. It is useful for testing specific server behaviors, such as error cases, HTTP headers, and timeouts. It will also require very little changes to your production code as you'll only need to change `serverUrl`.

`TestNetworkTransport` will replace the HTTP calls with preregistered GraphQL responses. It is more lightweight and requires more modifications to your production code.

## `TestNetworkTransport`

This is a high-level test API that enables you to specify the GraphQL responses that are returned by your `ApolloClient` instance.

Add the dependency to your project's `build.gradle` file:

```kotlin:title=build.gradle[.kts]
dependencies {
  testImplementation("com.apollographql.apollo3:apollo-testing-support:x.y.z")
}
```

Enable the `TestNetworkTransport` by passing it to the `ApolloClient` builder:

```kotlin{2}
val apolloClient = ApolloClient.Builder()
    .networkTransport(TestNetworkTransport())
    .build()
```

Use the `testNetworkTransport` extension function to retrieve the `TestNetworkTransport`:

```kotlin
val testNetworkTransport = apolloClient.testNetworkTransport
```

You can then use the `register` function to specify the responses that are returned for corresponding operations:

```kotlin{7}
val testQuery = GetHeroQuery("001")
val testData = GetHeroQuery.Data {
  hero = droidHero {
    name = "R2D2"
  }
}
apolloClient.testNetworkTransport.register(testQuery, testData)

val actual = apolloClient.query(testQuery).execute().data!!
assertEquals(testData.hero.name, actual.hero.name)
```

The `register` function accepts an `Operation` (here, the query) and the `ApolloResponse` to return when that operation executes. As a shortcut, you can pass a `Data` directly instead of an `ApolloResponse`, as shown in the example above.

> To help create your mocked response data, you can use [test builders](./test-builders/).

### Advanced usage

In some cases, you might want to return _different_ responses for the _same_ operation if it's executed multiple times.

To achieve this, instead of mapping operations to responses with `register`, you can **enqueue** a list of responses. When you do, these responses are returned in the order they were added.

To enqueue operations, pass a `QueueTestNetworkTransportHandler` to
the `TestNetworkTransport` and call its `enqueue` function:

```kotlin
val handler = QueueTestNetworkTransportHandler()
apolloClient = ApolloClient.Builder().networkTransport(TestNetworkTransport(handler)).build()

handler.enqueue(query, testData1)
handler.enqueue(query, testData2)
handler.enqueue(query, testData3)

val actual1 = apolloClient.query(query).execute().data
val actual2 = apolloClient.query(query).execute().data
val actual3 = apolloClient.query(query).execute().data
```

Note that you need to pass an operation to `enqueue`. This is because an `ApolloResponse` is built under the hood, which has a reference to an operation. There is also a version of `enqueue` that takes only an `ApoolloResponse` as a parameter.

If you need more control over the responses to return, you can implement your own `TestNetworkTransportHandler` and pass it to the `TestNetworkTransport`:

```kotlin
class CustomTestNetworkTransportHandler : TestNetworkTransportHandler {
  override fun handle(request: ApolloRequest<*>): ApolloResponse<*> {
    return ApolloResponse.Builder(
        /* Your custom logic here */
    ).build()
  }
}

apolloClient = ApolloClient.Builder()
    .networkTransport(TestNetworkTransport(CustomTestNetworkTransportHandler()))
    .build()
```

## `MockServer`

While `TestNetworkTransport` handles mocking at the GraphQL level, `MockServer` resides at the HTTP level and can mock arbitrary HTTP responses.

Add the dependency to your project's `build.gradle` file:

```kotlin:title=build.gradle[.kts]
dependencies {
  testImplementation("com.apollographql.apollo3:apollo-mockserver:x.y.z")
}
```

And here's how to use it:

```kotlin
// Create a mock server
val mockServer = MockServer()

// Use its URL on your ApolloClient
val apolloClient = ApolloClient.Builder().serverUrl(mockServer.url()).store(store).build()

// Enqueue responses
mockServer.enqueue("""{"data": {"random": 42}}""")
mockServer.enqueue(
    MockResponse(
        body = "Internal server error",
        statusCode = 500,
        headers = mapOf("X-Test" to "true"),
        // Optionally pass a delay to simulate network latency
        delayMillis = 1000L,
    )
)

// Execute queries
val response1 = apolloClient
    .query(GetRandomQuery())
    .execute()

val response2 = apolloClient
    .query(GetRandomQuery())
    .execute()

// Don't forget to stop the server when you're done
mockServer.stop()
```

Note how the `enqueue` function normally takes a `MockResponse` as a parameter, while a shorthand version that takes a `String` also exists.

### Advanced usage

By default, `MockServer` is configured with a `QueueMockServerHandler`, which will returns responses in the order they're added. If you need more control over the responses to return, you can implement your own `MockServerHandler` and pass it to the `MockServer`:

```kotlin
val customHandler = object : MockServerHandler {
  override fun handle(request: MockRequest): MockResponse {
    return if (/* Your custom logic here */) {
      MockResponse(
          body = """{"data": {"random": 42}}""",
          headers = mapOf("X-Test" to "true"),
      )
    } else {
      MockResponse(
          body = "Internal server error",
          statusCode = 500,
      )
    }
  }
}

val mockServer = MockServer(customHandler)
```

Note that if you use a custom `MockServerHandler`, calling `MockServer.enqueue()` is no longer possible because it expects the handler to be
a `QueueMockServerHandler`.
