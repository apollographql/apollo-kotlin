---
title: Multi Modules (experimental)
---

For multi-modules projects, Apollo Android allows to define queries in a feature module and reuse fragments and types from another module dependency. This helps with better separation of concerns and build times.

Support for multi-modules build is currently experimental and we'd love to have your feedback on it. Things that worked well, things that can be improved, etc.. You can reach out either through [Github issues](https://github.com/apollographql/apollo-android/issues/new?assignees=&labels=Type%3A+Bug&template=bug_report.md&title=[Multi-Modules]) or the [Kotlinlang slack channel](https://app.slack.com/client/T09229ZC6/C01A6KM1SBZ). We're looking forward to hearing from you!


## Setup

Multi-modules requires that one and only one module contains a schema. This is the schema that all other modules can reuse. In this document, we'll refer to it as the "schema module". 

Configure your schema module to generate Apollo metadata:

```kotlin
// schema/build.gradle.kts
apollo {
    generateApolloMetadata.set(true)
}
```

And declare your schema module as a dependency of your feature module:

```kotlin
// feature/build.gradle.kts
dependencies {
    implementation("com.apollographql.apollo:apollo-runtime:xyz")
    // more regular dependencies
    
    // Apollo dependencies
    apolloMetadata(project(":schema"))
    // You still need to declare the schema module as a regular dependency
    implementation(project(":schema"))
}
```

## Resolving Apollo dependencies

A feature module can have any number of apollo dependencies, each one contributing their types and fragments. 

Transitive Apollo dependencies will always expose their fragments and types to the modules downstream. In other words, there is no `implementation` vs `api` concept like there is for regular dependencies. Apollo dependencies will always expose everything downstream (i.e are treated as `api`). 

Another important thing to note is that all modules must share the same schema. Place schema.[graphqls | json] in the schema module, the module that is the higher up in the dependencies graph:

```kotlin
// feature/build.gradle.kts
// This module must not have a schema
// This module can use fragments and types from 'shared' and 'schema'
dependencies {
    apolloMetadata(project(":shared"))
}

// shared/build.gradle.kts
// This module can use fragments and types from 'schema'
dependencies {
    apolloMetadata(project(":schema"))
    generateApolloMetadata.set(true)
}

// schema/build.gradle.kts
// This module is the schema module
// Place the schema in this module 
dependencies {
    generateApolloMetadata.set(true)
}
```

Summary of different constraints:

* The schema module and only the schema module must define schema.[graphqls | json]
* The schema module and only the schema module must define `customTypeMapping`
* The schema module and only the schema module must define `generateKotlinModels`
* The schema module must have a `.graphql` file. This file can be empty
* All modules must apply the same version of the Apollo Gradle Plugin
* Either all modules must apply the Android plugin or no module should apply it

## Big schemas

When using multiple modules, Apollo Android will generate all possible Input Types and Enums in the schema module, and not only the used ones. This is because there is no way to know from the dependencies what types are going to be used in feature modules. By default:

* All input objects and enums are generated in the schema module.
* Fragments, queries, mutations and subscriptions are generated in the module where they are defined.

If your schema contains a lot of input objects, it can generate a lot of source files and increase compilation time beyond what's acceptable. To mitigate this, you have the option to control what types are generated with the `alwaysGenerateTypesMatching` option:

```kotlin
// schema/build.gradle.kts
apollo {
    generateApolloMetadata.set(true)
    // For the schema module, this defaults to [".*"]
    // To use the single-module behaviour of only generating types that are actually used, pass en empty list
    alwaysGenerateTypesMatching.set(emptyList())
}
```

If the same input object or enum is used in two sibling modules, the same type would end up being generated twice and an error will happen. You can fix this by instructing an upstream module to generate the common type:


```kotlin
// shared/build.gradle.kts
apollo {
    // Generate common types here
    // Here we specify the names of the types 
    alwaysGenerateTypesMatching.set(listOf("CommonInputType", "CommonEnum"))
    // It also works with regexes
    alwaysGenerateTypesMatching.set(listOf(".*Input"))
}
```

## Multiplatform

For multiplatform projects, put `apolloMetadata` in the top level `dependencies {}` block:

```kotlin
// feature/build.gradle.kts
// This module must not have a schema
// This module can use fragments and types from 'shared' and 'schema'
dependencies {
    apolloMetadata(project(":shared"))
}

kotlin {
    jvm()
    
    sourceSets {
        val commonMain by getting {
            dependencies {
                implementation(project(":shared"))
                implementation("com.apollographql.apollo:apollo-api:2.5.8")
                api("com.apollographql.apollo:apollo-runtime-kotlin:2.5.8")
            }
        }
    }
}
```

