---
title: Multi Modules (experimental)
---

For multi-modules projects, Apollo Android allows to define queries in a feature module and reuse fragments and types from another parent module. This helps with better separation of concerns and build times.

Support for multi-modules build is currently experimental and we'd love to have your feedback on it. Things that worked well, things that can be improved, etc.. You can reach out either through [Github issues](https://github.com/apollographql/apollo-android/issues/new?assignees=&labels=Type%3A+Bug&template=bug_report.md&title=[Multi-Modules]) or the [Kotlinlang slack channel](https://app.slack.com/client/T09229ZC6/C01A6KM1SBZ). We're looking forward to hearing from you!


## Setup

Multi-modules requires that one module and only one contains a schema. This is the schema that all other modules can reuse. In this document, we'll name it "graphql-root". This is **not to be confused with Gradle root project** that contains all your modules.

Configure your "graphql-root" module to generate Apollo metadata:

```kotlin
// graphql-root/build.gradle.kts
apollo {
    generateApolloMetadata.set(true)
}
```

And declare your graphql-root module as a dependency of your feature module:

```kotlin
// feature/build.gradle.kts
dependencies {
    implementation("com.apollographql.apollo:apollo-runtime:xyz")
    // more regular dependencies
    
    // Apollo dependencies
    apolloMetadata(project(":graphql-root"))
    // You still need to declare the graphql-root module as a regular dependency
    implementation(project(":graphql-root"))
}
```

## Resolving Apollo dependencies

A feature module can have any number of parent modules. Parent modules themselves can also have parents, creating a graph of dependencies. 

Transitive Apollo dependencies will always expose their fragments and types to the modules downstream. In other words, there is no `implementation` vs `api` concept like there is for regular dependencies. Apollo dependencies will always expose everything downstream (i.e are treated as `api`). 

Another important thing to note is that all modules must share the same schema. Place schema.[json | sdl] in the graphql root module, the module that is the higher up in the dependencies graph:

```kotlin
// feature/build.gradle.kts
// This module must not have a schema
// This module can use fragments and types from 'shared' and 'graphql-root'
dependencies {
    apolloMetadata(project(":shared"))
}

// shared/build.gradle.kts
// This module can use fragments and types from 'graphql-root'
dependencies {
    apolloMetadata(project(":graphql-root"))
    generateApolloMetadata.set(true)
}

// graphql-root/build.gradle.kts
// This module is the graphql root module
// Place the schema in this module 
dependencies {
    generateApolloMetadata.set(true)
}
```

Summary of different constraints:

* The graphql root module and only the graphql root module must define schema.[json | sdl]
* The graphql root module and only the graphql root module must define `customTypeMapping`
* The graphql root module and only the graphql root module must define `generateKotlinModels`
* The graphql root module must have a `.graphql` file. This file can be empty
* All modules must apply the same version of the Apollo Gradle Plugin
* Either all modules must apply the Android plugin or no module should apply it

## Big schemas

When using multiple modules, Apollo Android will generate all possible Input Types and Enums in the graphql root module, and not only the used ones. This is because there is no way to know from the parent module what types are going to be used in feature modules. By default:

* All input objects and enums are generated in the graphql root module.
* Fragments, queries, mutations and subscriptions are generated in the module where they are defined.

If your schema contains a lot of input objects, it can generate a lot of source files and increase compilation time beyond what's acceptable. To mitigate this, you have the option to control what types are generated with the `alwaysGenerateTypesMatching` option:

```kotlin
// parent/build.gradle.kts
apollo {
    generateApolloMetadata.set(true)
    // For the graphql root module, this defaults to [".*"]
    // To use the single-module behaviour of only generating types that are actually used, pass en empty list
    alwaysGenerateTypesMatching.set(emptyList())
}
```

If the same input object or enum is used in two sibling modules, the same type would end up being generated twice and an error will happen. You can fix this by instructing an upstream module to generate the common type:


```kotlin
// common/build.gradle.kts
apollo {
    generateApolloMetadata.set(true)
    // Generate common types here
    // Here we specify the names of the types 
    alwaysGenerateTypesMatching.set(listOf("CommonInputType", "CommonEnum"))
    // It also works with regexes
    alwaysGenerateTypesMatching.set(listOf(".*Input"))
}
```

## Multiplatform

For multiplatform projects, put `apolloMetadata` in the top level `dependencies {}` block:

```kotlin
// feature/build.gradle.kts
// This module must not have a schema
// This module can use fragments and types from 'shared' and 'graphql-root'
dependencies {
    apolloMetadata(project(":shared"))
}

kotlin {
    jvm()
    
    sourceSets {
        val commonMain by getting {
            dependencies {
                implementation("com.apollographql.apollo:apollo-api:2.5.8")
                api("com.apollographql.apollo:apollo-runtime-kotlin:2.5.8")
            }
        }
    }
}
```

