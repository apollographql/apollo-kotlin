---
title: JS Interoperability
---

[Kotlin/JS](https://kotlinlang.org/docs/js-overview.html) is a powerful tool that allows you to compile
Kotlin down to Javascript. `apollo-runtime` supports JS interop out of the box with no code changes required.

With that said, the default implementation has some performance limitations. Kotlin/JS adds a significant
amount of overhead to basic Kotlin data structures (notably `List`, `Set`, and `Map`), and so performance sensitive
workloads (like those found in the Kotlin JSON parsing codepaths) can be slow.

To work around this, the Apollo compiler provides an option that allows you to to skip the JSON parsing
step completely on JS platforms. To make use of this, you must set `jsExport.set(true)` on your service,
and then you can `unsafeCast()` a JSON parsed response directly to the generated model. Take careful note of the limitations listed below.

## Example

```kotlin
// build.gradle
apollo {
  service("service") {
    packageName.set("jsexport")
    jsExport.set(true)
    codegenModels.set("responseBased")
  }
}

data class SimpleApolloResponse<D : Operation.Data>(val data: D?)

expect suspend fun <D : Operation.Data> JsonHttpClient.executeApolloOperation(
    operation: Operation<D>,
    headers: Array<Array<String>> = emptyArray(),
    method: HttpMethod = HttpMethod.Post
): SimpleApolloResponse<D>

// non-js implementation
actual suspend fun <D : Operation.Data> JsonHttpClient.executeApolloOperation(
    operation: Operation<D>,
    headers: Array<Array<String>> = emptyArray(),
    method: HttpMethod = HttpMethod.Post
): SimpleApolloResponse<D> {

  val body = buildJsonString {
      operation.composeJsonRequest(this)
  }
  val bytes = yourHttpClient.execute(somePath, body)
  val response = operation.parseJsonResponse(BufferedSourceJsonReader(Buffer().write(bytes)))
  return SimpleApolloResponse(response.data)
}

// js implementation
actual suspend fun <D : Operation.Data> JsonHttpClient.executeApolloOperation(
    operation: Operation<D>,
    headers: Array<Array<String>> = emptyArray(),
    method: HttpMethod = HttpMethod.Post
): SimpleApolloResponse<D> {

  val body = buildJsonString {
      operation.composeJsonRequest(this)
  }
  val response = fetch(somePath, body).await()
  val dynamicJson = response.json().await().asDynamic()
  return SimpleApolloResponse(data = dynamicJson["data"].unsafeCast())
}
```

For a more complete example see [this gist](https://gist.github.com/baconz/778e8a0b359267292d6e05ad81c19b90) which uses
ktor for non-JS clients.

## Limitations
* `JsExport` only makes sense on response based codegen since it will be in a shape that matches the parsed JSON.
* Extension functions on generated code break when you use this technique since we are casting a raw JS object and not actually instantiating a class.
* `generateAsInternal = true` does not work with `JsExport`, since the compiler ends up giving the internal modifier precedence, and thus mangling the property names.
* Custom adapters can only be used when their target types are supported by JS (see the full list of [supported types](https://kotlinlang.org/docs/js-to-kotlin-interop.html#kotlin-types-in-javascript)).
* Enums will be generated as `String`, and so you must cast them at runtime.
* `GraphQLList` will be generated as `Array` instead of `List`.

## Accessors and Polymorphism
Typically `responseBased` codegen would create companion objects with accessors for polymorphic models. For example:

```kotlin
public interface Animal {
  public val __typename: String

  public val species: String

  public companion object {
    public fun Animal.asLion() = this as? Lion

    public fun Animal.asCat() = this as? Cat
  }
}
```

Unfortunately, `JsExport` does not support companion objects, and extension functions wouldn't work if we generated them
(see limitations above), so accessors are completely disabled on generated code when `JsExport` is enabled. With that said,
we provide a convenience extension function called `unsafeCastOrCast()` which can be used from common code and will appropriately
cast JS and non-JS code. So your parsing code might look something like:

```kotlin
when(animal.__typename) {
   "Lion" -> animal.unsafeCastOrCast<Lion>()
   "Cat" -> animal.unsafeCastOrCast<Cat>()
}
```

## How it works
Javascript is a dynamic language, which means that if you don't need methods/prototype functionality
you can cast an arbitrary JS object to generated code that matches its shape. For example consider this Javascript:

```javascript
// Imagine Kotlin generated a class like this:
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

// And we had data like this:
val point = {
  x: 10
  y: 10
}

// This would be perfectly valid code, even though `point` is not actually a `Point`:
console.log(point.x)
```

In Kotlin this would look like:

```kotlin
data class Point(val x: Int, val y: Int)

val point = jso<dynamic> {
    x = 10
    y = 10
}

val typedPoint = point.unsafeCast<Point>()

console.log(typedPoint.x)
```

But! That code would fail with a `RuntimeException` because, by default the Kotlin compiler mangles properties,
which means that the generated code for the `Point` data class, ends up looking like this after Kotlin compiles it:

```javascript
class Point {
  constructor(x, y) {
    this.x_1 = x;
    this.y_1 = y;
  }
}
```

To work around this, you need to tell the compiler not to mangle property names, which you can do by annotating the class
with `JsExport`. When you set the `jsExport` option on your service, you tell Apollo to annotate each generated
class with `JsExport` so that the property names are not mangled, and you can safely cast.

## Alternative approaches


### Use `DynamicJsJsonReader`
If you would prefer to use `operationBased` models, and performance is not _as_ critical, you can use `DynamicJsJsonReader`. In JS
simply looping through the byte array incurs a lot of overhead because Kotlin uses `Long` indices in its Arrays, and Longs do not
have a JS implementation. The `DynamicJsJsonReader` takes a javascript object that has already been parsed from JSON, and turns
it into Apollo `Data`.

In testing we've seen a ~2x performance boost on JS platforms using this parser vs ~10x with the `JsExport` approach.

To use `DynamicJsJsonReader`, your JS implementation above would become:

```kotlin
// js implementation
actual suspend fun <D : Operation.Data> JsonHttpClient.executeApolloOperation(
    operation: Operation<D>,
    headers: Array<Array<String>> = emptyArray(),
    method: HttpMethod = HttpMethod.Post
): ApolloResponse<D> {

  val body = buildJsonString {
      operation.composeJsonRequest(this)
  }
  val response = fetch(somePath, body).await()
  val dynamicJson = response.json().await().asDynamic()
  return operation.parseJsonResponse(DynamicJsJsonReader(dynamicJson)
}
```


### Use [JSEI](https://github.com/apollosolutions/apollo-jsei)
If you do not need to interop with non-JS platforms (eg JVM/Apple/Native), or you are comfortable with some code duplication for the JS
side you can use [JSEI](https://github.com/apollosolutions/apollo-jsei), which uses the `apollo-ast` to generate Javascript `external interfaces`
that you can cast to similar to the `JsExport` approach. The disadvantage is that `external interfaces` can only be used from Javascript targeted code,
so you cannot reference the models in common code.