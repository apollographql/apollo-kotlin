---
title: Authenticate your operations
---

> Authentication is not included in the GraphQL specification. This page aims at giving some guidance for the most common scenarios but doesn't intend to be exhaustive.

## Authenticating your HTTP requests with OkHttp

[OkHttp Interceptors](https://square.github.io/okhttp/features/interceptors/) are an easy way to add an `"Authorization"` header to your HTTP requests.

OkHttp Interceptors have been around for a long time and work well but can only be used with Apollo Kotlin on Android and the JVM.

## Authenticating your HTTP requests with Apollo HttpInterceptor

To authenticate your HTTP requests in a multi-platform way, you can use an Apollo [HttpInterceptor](./interceptors-http).

HttpInterceptor is multiplatform and uses an API very similar to OkHttp's:

```kotlin
class AuthorizationInterceptor() : HttpInterceptor {
  private val mutex = Mutex()

  override suspend fun intercept(request: HttpRequest, chain: HttpInterceptorChain): HttpResponse {
    var token = mutex.withLock {
      // get current token
    }

    val response = chain.proceed(request.newBuilder().addHeader("Authorization", "Bearer $token").build())

    return if (response.statusCode == 401) {
      token = mutex.withLock {
        // get new token
      }
      chain.proceed(request.newBuilder().addHeader("Authorization", "Bearer $token").build())
    } else {
      response
    }
  }
}
```

For a more advanced example, you can take a look at the [AuthorizationInterceptor integration tests](https://github.com/apollographql/apollo-kotlin/blob/6f0b798198c215013f12e7da509624a1befc1b73/apollo-runtime/src/commonTest/kotlin/com/apollographql/apollo3/network/AuthorizationInterceptor.kt#L30)

## Authenticate your subscriptions with an HTTP header or query parameter

`ApolloClient` creates different WebSockets for different header values. Use an interceptor to change the header value on error:

```kotlin
private class UpdateAuthorizationHeaderInterceptor : ApolloInterceptor {
  @OptIn(ExperimentalCoroutinesApi::class)
  override fun <D : Operation.Data> intercept(request: ApolloRequest<D>, chain: ApolloInterceptorChain): Flow<ApolloResponse<D>> {
    return flow {
      // Retrieve a new access token every time
      val request = if (request.operation is Subscription<*>) {
        request.newBuilder()
            // Update the HTTP header
            .addHttpHeader("Authorization", "Bearer ${accessToken()}")
            // Or change the url
            .url("https://example.com/subscription?token=${accessToken()}")
            .build()
      } else {
        request
      }

      emitAll(chain.proceed(request))
    }
  }
}
```

Note: The client shares WebSockets in a pool. If your access token changes frequently, the client might open multiple WebSockets concurrently.

## Authenticate your subscriptions with a connection payload

The connection payload is specific to the `WsProtocol`. Pass a lambda to the `WsProtocol` constructor that the client evaluates whenever it creates a WebSocket.

```kotlin
ApolloClient.Builder()
  .httpServerUrl(mockServer.url())
  .subscriptionNetworkTransport(
      WebSocketNetworkTransport.Builder()
          .serverUrl(mockServer.url())
          .wsProtocol(GraphQLWsProtocol(
              connectionPayload = {
                getFreshConnectionPayload()
              }
          ))
          .build()
  )
  .build()
```

## Retry your subscriptions automatically

The preceding approaches require your backend to indicate when a token expires. Unlike HTTP 401 errors, WebSockets lack a widespread standard for expiration signaling.

If your backend closes the WebSocket, retry subscriptions automatically using `retryOnError { it.operation is Subscription }`:

```kotlin
ApolloClient.Builder()
  .serverUrl(mockServer.url())
  .retryOnError { it.operation is Subscription }
```

For other cases, customize your `RetryStrategy`. For details, see [Network errors](network-errors).