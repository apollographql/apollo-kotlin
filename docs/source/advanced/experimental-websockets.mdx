---
title: Experimental websockets
---

> ⚠️ **Experimental websockets APIs are [experimental](https://www.apollographql.com/docs/resources/release-stages/#experimental-features) in Apollo Kotlin.** If you have feedback on them, please let us know via [GitHub issues](https://github.com/apollographql/apollo-kotlin/issues/new?assignees=&labels=Type%3A+Bug&template=bug_report.md&title=[Defer%20Support]) or in the [Kotlin Slack community](https://slack.kotl.in/).


Historically, WebSockets have been one of the most complex and error prone parts of Apollo Kotlin because:

1. The transport is not specified and different implementations have different behaviours.
2. WebSockets are stateful and making them work using the old memory model was challenging.
3. Because WebSockets are long-lived connections, they are more exposed to errors and knowing when (or if) to retry is hard.

Starting with 4.0.0, Apollo Kotlin provides `WebSocketNetworkTransport` and `WebSocketEngine` in the `com.apollographql.apollo3.network.websocket` package (instead of `com.apollographql.apollo3.network.ws` for the current implementation).

They:

1. Default to the [graphql-ws](https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md) protocol, which has become the de facto standard. Using the other protocols is still possible but having a main, specified, protocol ensures we can write a good test suite.
2. Do inherit from the old memory model design, making the code considerably easier. In particular, `WebSocketEngine` is now event based and no flow control is done. If you buffers grow too much, your subscription fails.
3. Play nicely with the ApolloClient `retryOnError` API.

## Status

While they are called "experimental", we believe the new APIS to be more robust that the non-experimental ones. They are safe to use in non-lib use cases.

The "experimental" tag is permission to do API breaking change based on community feedback. Ideally there is no change needed.

After a feedback phase, the current `ws.` APIs will become deprecated and the `websocket.` one promoted to stable. 

## Migration guide

Replace `com.apollographql.apollo3.network.ws` with `com.apollographql.apollo3.network.websocket` everywhere:

```kotlin
// Replace
import com.apollographql.apollo3.network.ws.WebSocketNetworkTransport
import com.apollographql.apollo3.network.ws.WebSocketEngine
// etc...

// With
import com.apollographql.apollo3.network.websocket.WebSocketNetworkTransport
import com.apollographql.apollo3.network.websocket.WebSocketEngine
// etc...
```

Replace `ApolloClient.Builder` function with their equivalent on `WebSocketNetworkTransport`:

```kotlin
// Replace
val apolloClient = ApolloClient.Builder()
    .serverUrl(serverUrl)
    .webSocketServerUrl(webSocketServerUrl)
    .webSocketEngine(myWebSocketEngine)
    .webSocketIdleTimeoutMillis(10_000)
    .build()

// With
import com.apollographql.apollo3.network.websocket.WebSocketNetworkTransport
    
ApolloClient.Builder()
    .serverUrl(serverUrl)
    .subscriptionNetworkTransport(
        WebSocketNetworkTransport.Builder()
            .serverUrl(webSocketServerUrl)
            // If you didn't set a WsProtocol before, make sure to include this 
            .wsProtocol(SubscriptionWsProtocol())
            // If you were already using GraphQLWsProtocol, this is now the default
            //.wsProtocol(GraphQLWsProtocol())
            .webSocketEngine(myWebSocketEngine)
            .idleTimeoutMillis(10_000)
            .build()
    )
    .build()
```

To account for non-websocket transports, like [multipart subscriptions](https://www.apollographql.com/docs/router/executing-operations/subscription-multipart-protocol/), the retry is now handled on the [ApolloClient] instead of the [NetworkTransport].

```kotlin
// Replace
val apolloClient = ApolloClient.Builder()
    .subscriptionNetworkTransport(
        WebSocketNetworkTransport.Builder()
            .serverUrl(url)
            .reopenWhen { _, _ ->
              delay(1000)
              true
            }
            .build()
    )

// With
val apolloClient = ApolloClient.Builder()
    .subscriptionNetworkTransport(
        WebSocketNetworkTransport.Builder()
            .serverUrl(url)
            .build()
    )
    // Only retry subscriptions
    .retryOnError { it.operation is Subscription }
```

The above uses the default retry algorithm:

* Wait until the network is available if you configured a [NetworkMonitor](network-connectivity)
* Or use exponential backoff else

To customize the retry logic more, use `addRetryOnErrorInterceptor`:

```kotlin
val apolloClient = ApolloClient.Builder()
    .subscriptionNetworkTransport(
        WebSocketNetworkTransport.Builder()
            .serverUrl(url)
            .build()
    )
    .addRetryOnErrorInterceptor { apolloRequest, exception, attempt -> 
      // retry logic here
      
      // return true to retry or false to terminate the Flow
      true
    }
```