---
title: Handling nullability and errors
description: Make your queries even more typesafe
---

## Nullability in GraphQL

GraphQL does not have a `Result` type. If a field errors, it is set to `null` in the JSON response and an error is added to the `errors` array. With the following schema and query:

```graphql
type User {
  id: ID!
  # name is nullable to account for possible errors 
  # but in practice this happens only in error cases
  name: String
  avatarUrl: String
}

query GetUser {
  user {
    id
    name
    avatarUrl
  }
}
```

the server returns the following response in case of error:

```json
{
  "data": {
    "user": {
      "id": "1001",
      "name": null,
      "avatarUrl": "https://example.com/pic.png"
    }
  },
  "errors": [
    {
      "message": "Cannot resolve user.name",
      "path": ["user", "name"]
    }
  ]
}
```

GraphQL best practices recommend using nullable types by default. From [graphql.org](https://graphql.org/learn/best-practices/#nullability):

```
However, in a GraphQL type system, every field is nullable by default. 
This is because there are many things that can go awry in a networked
service backed by databases and other services.
```

This default makes sense in distributed environments where microservices might fail and some data fail to resolve. This behaviour is robust by default: if part of your query fails, you still get the rest of the data.

This default has one major drawback for frontend developers. It requires to carefully check every field when used in your UI. Sometimes it's not clear how to handle the different cases:

```kotlin
@Composable
fun User(user: GetUserQuery.User) {
  if (user.name != null) {
    Text(text = user.name)
  } else {
    // What to do here? 
    // Is it an error? 
    // Is it a true null?
    // Should I display a placeholder? an error? hide the view?
  }
}
```

To help deal with those issues and make sure your UI code only sees what make sense for your app, Apollo Kotlin offers three tools:
* error aware parsing
* `@catch`
* `@nullOnlyOnError` 

## Error aware parsing

With error aware parsing, the errors are detected at parsing time, so you don't have to look them up in the `errors` array. Any GraphQL error stops the parsing and you are guaranteed that `response.data` is actual semantic data and does not contain any error. 

In order to opt-in error aware parsing, create a `extra.graphqls` file next to your schema and import the `@catch` directive:

```graphql
# Import the `@catch` directive definition. 
# When the `@catch` directive definition, parsers generate extra code to deal with errors.
extend schema @link(url: "https://specs.apollo.dev/nullability/v0.1", import: ["@catch"])
```

Once error aware parsing is enabled, the parsing stops at the first GraphQL error and the whole query is failed. In the example above:

```json
{
  "data": {
    "user": {
      "id": "1001",
      "name": null,
      "avatarUrl": "https://example.com/pic.png"
    }
  },
  "errors": [
    {
      "message": "Cannot resolve user.name",
      "path": ["user", "name"]
    }
  ]
}
```

`response.data` is null and `response.exception` is an instance of `ApolloGraphQLException`:

```kotlin
println(response.data) // null
println(response.exception) // ApolloGraphQLException 
```

This default makes it easy to handle errors as they are all handled at parsing time. If you see a `null` in `response.data`, you are guaranteed it is a semantic null and not an error, and you should probably handle it.

Sometimes failing the whole query feels a bit overkill though. For those cases, you can handle errors with `@catch`.

## Handle errors and receive partial data with `@catch`

In some cases, you might want to display the data returned from the server, even if it is partial. 

To do so, catch GraphQL errors using the `@catch` directive:

```graphql
query GetUser {
  user {
    id
    # map name to FieldResult<String?> instead of stopping parsing
    name @catch
    avatarUrl
  }
}
```

Instead of failing the whole query, the `name` field is now generated as a `FieldResult<String?>` class that can contain either a nullable value or an error:

```kotlin
// name does not have a value
println(response.data?.user?.name?.valueOrNull) // null
// but name has an error
println(response.data?.user?.name?.errorOrNull?.message) // "Cannot resolve user.name"
// partial data is available
println(response.data?.user?.id) // "42"
// exception is null
println(response.exception) // null
```

For fields of List type, `@catch` applies to all list levels by. If you need to apply it to a given level, use the `level` argument:

```graphql
query GetUser {
  user {
    # socialLinks fails the operation on error 
    # socialLinks[0], socialLinks[1], socialLinks[2], etc... are mapped to FieldResult classes
    socialLinks @catch(level: 1)
  }
}
```

## Handle semantic non-null with `@nullOnlyOnError`

Even with automatic detection of errors and handling of partial data like described above, you still have to check for `null` in your UI code. This is because of the same reason that [GraphQL by default recommends nullable fields](https://graphql.org/learn/best-practices/#nullability). Your backend team has no other choice than make a field nullable if it can fail. 

But a field like 'User.name', it would make sense that it's always non-null unless something goes really wrong. 

In those cases, you can mark a field as "null only on error" and the Apollo Kotlin compiler will generate it as non-nullable even if nullable in the server schema. To do so, add `@nullOnlyOnError` to your `extra.graphqls` file:

```graphql
# extra.graphqls

# Import the `@nullOnlyOnError` directive definition in addition to `@catch`. 
extend schema @link(url: "https://specs.apollo.dev/nullability/v0.1", import: ["@catch", "@nullOnlyOnError"])
# make User.name nullable only on error
extend type User @nullOnlyOnError(field: "name")
```

`name` is now a non-null Kotlin types:

```kotlin
class User(
    val id: String,
    // name is non-null here
    val name: String,
    val avatarUrl: String?,
)
```

If, by any chance, an error happens that you still want to handle on that field, you can use `@catch` to map name to a `FieldResult<String>` property containing a non-null value or an error.

```kotlin
user.name.valueOrNull // "Luke Skywalker"
user.name.errorOrNull // null
```

Similarly to `@catch`, `@nullOnlyOnError` supports a `level` argument for lists:

```graphql
# User.friends is generated a nullable
# User.friends[0], User.friends[1], User.friends[2], etc.. is generated a non-null
extend type User @nullOnlyOnError(field: "friends", level: 1)
```